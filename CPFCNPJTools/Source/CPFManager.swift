//
//  CPFValidator.swift
//  CPF-CNPJ-TOOLS
//
//  Created by Diggo Silva on 16/11/24.
//

import Foundation

/// Enum representing the different statuses of a CPF after validation.
public enum CPFStatus {
    case valid         // Valid CPF.
    case invalid       // Invalid CPF.
    case cpfNull       // CPF cannot be null or empty.
    case equalDigits   // CPF with repeated digits is not valid (e.g., 111.111.111-11, which is invalid because it's a repeated number).
    case invalidFormat // Invalid CPF.\nCPF must have 11 digits (only numbers).
}

/// Manages operations related to `CPF (Brazilian Taxpayer ID), such as validation, generation, and formatting.
public class CPFManager {
    
    public init() {}
    
    /// Validates a given CPF, checking if it is valid, properly formatted, and if the verification digits are correct.
    ///
    /// - Parameter cpf: The CPF to be validated. It may contain non-numeric characters (dots, hyphens, etc.).
    /// - Returns: A `CPFStatus` value indicating the validation status.
    ///
    /// The `CPFStatus` enum can have the following values:
    /// - `.valid`: Indicates the CPF is valid.
    /// - `.invalid`: Indicates the CPF is invalid.
    /// - `.cpfNull`: Indicates the CPF is empty.
    /// - `.invalidFormat`: Indicates the CPF has an invalid format (wrong number of digits, contains letters, etc.).
    /// - `.equalDigits`: Indicates the CPF contains the same digit repeated (e.g., "111.111.111-11").
    ///
    ///  **Example:**
    /// ```swift
    /// let cpfManager = CPFManager()
    /// let status = cpfManager.validate(cpf: "111.444.777-35")
    /// print(status)  // .valid or .invalid
    /// ```
    public func validate(cpf: String) -> CPFStatus {
        let cleanedCPF = cpf.replacingOccurrences(of: "[^0-9]", with: "", options: .regularExpression)
        
        guard cleanedCPF.count > 0 else { return .cpfNull }
        
        guard cleanedCPF.count == 11, cleanedCPF.allSatisfy({ $0.isNumber }) else { return .invalidFormat }
        
        if Set(cleanedCPF).count == 1 { return .equalDigits }
        
        let cpfBaseDigits = cleanedCPF.prefix(9).compactMap({ Int(String($0)) })
        let providedCheckDigits = cleanedCPF.suffix(2).compactMap({ Int(String($0)) })
        
        let calculated1stCheckDigit = Double(calculateCPFCheckSum(cpfBaseDigits: cpfBaseDigits, multiplyBy: 10)).truncatingRemainder(dividingBy: 11)
        let firstCheckDigit = calculated1stCheckDigit < 2 ? 0 : 11 - Int(calculated1stCheckDigit)
        
        let calculated2ndCheckDigit = Double(calculateCPFCheckSum(cpfBaseDigits: cpfBaseDigits + [firstCheckDigit], multiplyBy: 11)).truncatingRemainder(dividingBy: 11)
        let secondCheckDigit = calculated2ndCheckDigit < 2 ? 0 : 11 - Int(calculated2ndCheckDigit)
        
        if firstCheckDigit == providedCheckDigits.first, secondCheckDigit == providedCheckDigits.last {
            return .valid
        } else {
            return .invalid
        }
    }
    
    private func generate() -> String {
        var get9RandomNumbers = (0..<9).compactMap({ _ in Int.random(in: 0...9) })
        
        let calculated1stCheckDigit = Double(calculateCPFCheckSum(cpfBaseDigits: get9RandomNumbers, multiplyBy: 10)).truncatingRemainder(dividingBy: 11)
        calculated1stCheckDigit < 2 ? get9RandomNumbers.append(0) : get9RandomNumbers.append(11 - Int(calculated1stCheckDigit))
        
        let calculated2ndCheckDigit = Double(calculateCPFCheckSum(cpfBaseDigits: get9RandomNumbers, multiplyBy: 11)).truncatingRemainder(dividingBy: 11)
        calculated2ndCheckDigit < 2 ? get9RandomNumbers.append(0) : get9RandomNumbers.append(11 - Int(calculated2ndCheckDigit))
        
        let generatedFakeCPF = get9RandomNumbers.map({ String($0) }).joined()
        
        return validate(cpf: generatedFakeCPF) == .valid ? generatedFakeCPF : generate()
    }
    
    /// Generates a random valid CPF and returns it already formatted with the mask (XXX.XXX.XXX-XX).
    ///
    /// - Returns: The generated CPF formatted with the mask.
    ///
    /// - Warning: The CPF generated by this method is **valid** (based on CPF validation rules), but **it is not a real CPF**.
    ///   It does not correspond to a real person and should **not be used for any fraudulent, illegal, or deceptive purposes**.
    ///   This method is intended solely for **testing or simulation purposes** in development and software testing environments.
    ///
    /// **Example:**
    /// ```swift
    /// let cpfManager = CPFManager()
    /// let formattedCpf = cpfManager.generateMasked()
    /// print(formattedCpf)  // Example output: "111.444.777-35"
    /// ```
    public func generateMasked() -> String? {
        return format(generate())
    }
    
    private func format(_ cpf: String) -> String? {
        guard cpf.count == 11 else { return nil }
        let formattedCPF = "\(cpf.prefix(3)).\(cpf.dropFirst(3).prefix(3)).\(cpf.dropFirst(6).prefix(3))-\(cpf.suffix(2))"
        return formattedCPF
    }
    
    private func calculateCPFCheckSum(cpfBaseDigits: [Int], multiplyBy: Int) -> Int {
        var multiplyBy = multiplyBy
        var checkSum = 0
        
        for digit in cpfBaseDigits {
            checkSum += digit * multiplyBy
            multiplyBy -= 1
        }
        return checkSum
    }
    
    /// Masks a given CPF by adding typical separators `XXX.XXX.XXX-XX`.
    ///
    /// - Parameter cpf: The CPF to be masked. It may contain non-numeric characters.
    /// - Returns: The CPF masked in the format `XXX.XXX.XXX-XX`.
    ///
    /// - **Note**:
    /// This method can be used in a `UITextField`'s delegate to format the CPF input while the user types.
    ///
    /// - **Example**:
    /// ```swift
    /// let cpfManager = CPFManager()
    /// let maskedCpf = cpfManager.mask(cpf: "11144477735")
    /// print(maskedCpf)  // "111.444.777-35"
    /// ```
    /// **Usage in UITextField Delegate**:
    ///
    /// - Tip: In your `UITextField` delegate, you can use this method to format the CPF input as follows:
    ///
    /// ```swift
    /// func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
    ///     guard let currentText = textField.text else { return true }
    ///     let newText = (currentText as NSString).replacingCharacters(in: range, with: string)
    ///     textField.text = cpfManager.mask(cpf: newText)
    ///     return false // Prevent the default text change, as we are setting it manually
    /// }
    /// ```
    public func mask(cpf: String) -> String {
        var originalText = cpf.replacingOccurrences(of: "[^0-9]", with: "", options: .regularExpression)
        
        if originalText.count > 11 {
            originalText = String(originalText.prefix(11))
        }
        var maskedText = ""
        
        for (index, char) in originalText.enumerated() {
            if index == 3 || index == 6 {
                maskedText.append(".")
            } else if index == 9 {
                maskedText.append("-")
            }
            maskedText.append(char)
        }
        return maskedText
    }
}
